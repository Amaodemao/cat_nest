import { promises as fs } from "node:fs";
import path from "node:path";
import React from "react";
import matter from "gray-matter";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import remarkMath from "remark-math";
import rehypeRaw from "rehype-raw";
import rehypeKatex from "rehype-katex";
import { renderToStaticMarkup } from "react-dom/server";

const BLOGS_DIR = path.resolve(process.cwd(), "src/blogs");
const OUTPUT_FILE = path.resolve(process.cwd(), "src/data/generatedPosts.ts");

function formatDateText(dateISO) {
  const match = /^(\d{4})-(\d{2})-(\d{2})$/.exec(dateISO);
  if (!match) return dateISO || "Unknown date";
  const [, year, month, day] = match;
  return `${month}/${day}/${year}`;
}

function normalizeDate(value) {
  if (typeof value === "string") {
    const trimmed = value.trim();
    if (!trimmed) return "";
    if (/^\d{4}-\d{2}-\d{2}/.test(trimmed)) return trimmed.slice(0, 10);
    const parsed = new Date(trimmed);
    if (!Number.isNaN(parsed.getTime())) return parsed.toISOString().slice(0, 10);
    return trimmed;
  }
  if (value instanceof Date && !Number.isNaN(value.getTime())) {
    return value.toISOString().slice(0, 10);
  }
  return "";
}

function normalizeTags(tags) {
  if (!tags) return [];
  if (Array.isArray(tags)) return tags.map((t) => String(t).trim()).filter(Boolean);
  return String(tags)
    .split(",")
    .map((t) => t.trim())
    .filter(Boolean);
}

function toSlug(filePath) {
  const filename = filePath.split("/").pop() ?? "post";
  return filename.replace(/\.md$/i, "");
}

async function collectMarkdownFiles(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = await Promise.all(
    entries.map(async (entry) => {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory()) return collectMarkdownFiles(fullPath);
      if (entry.isFile() && entry.name.toLowerCase().endsWith(".md")) return [fullPath];
      return [];
    })
  );
  return files.flat();
}

function markdownToHtml(markdown) {
  const element = React.createElement(
    ReactMarkdown,
    {
      remarkPlugins: [remarkGfm, remarkMath],
      rehypePlugins: [rehypeRaw, rehypeKatex],
    },
    markdown
  );
  return renderToStaticMarkup(element);
}

async function main() {
  const mdFiles = await collectMarkdownFiles(BLOGS_DIR);
  const posts = await Promise.all(
    mdFiles.map(async (filePath) => {
      const raw = await fs.readFile(filePath, "utf8");
      const { data, content } = matter(raw);

      if (data.published === false) return null;

      const unixPath = filePath.split(path.sep).join("/");
      const slug = toSlug(unixPath);
      const dateISO = normalizeDate(data.date);
      const title =
        typeof data.title === "string" && data.title.trim() ? data.title.trim() : slug;
      const excerpt = typeof data.introduction === "string" ? data.introduction.trim() : "";
      const html = markdownToHtml(content);

      return {
        title,
        dateISO,
        dateText: formatDateText(dateISO),
        excerpt,
        tags: normalizeTags(data.tags),
        slug,
        html,
      };
    })
  );

  const outputPosts = posts
    .filter((post) => post !== null)
    .sort((a, b) => b.dateISO.localeCompare(a.dateISO));

  const output = `/* eslint-disable */
// This file is auto-generated by scripts/generate-posts.mjs
// Do not edit manually.

export type Post = {
  title: string;
  dateISO: string;
  dateText: string;
  excerpt: string;
  tags: string[];
  slug: string;
  html: string;
};

export const posts: Post[] = ${JSON.stringify(outputPosts, null, 2)};
`;

  await fs.writeFile(OUTPUT_FILE, output, "utf8");
  console.log(`Generated ${outputPosts.length} posts -> ${OUTPUT_FILE}`);
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
